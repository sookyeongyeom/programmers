function solution(N, stages) {
	let stageData = {};
	let range = [...Array(N).keys()].map((v) => v + 1); // 1~5
	range.map((v, i) => (stageData[i + 1] = { stuck: 0, total: 0 }));

	stages.map((v, i) => {
		if (v <= N) stageData[v].stuck += 1;
		for (let i = 1; i <= v && i <= N; i++) stageData[i].total += 1;
	});

	return range.sort(
		(a, b) => stageData[b].stuck / stageData[b].total - stageData[a].stuck / stageData[a].total,
	);
}

solution(5, [2, 1, 2, 6, 2, 4, 3, 3]);

/*
문제를 푸는 절차를 만들자

1. 문제를 정확히 이해하자
2. 이해가 안될 땐 입출력 예제를 보자
3. 필요한 자료의 모양을 글자로 써보자
4. 설계를 마치면 구현하자
5. 자료를 먼저 만들어내지못하면 그냥 못푸는거다
6. 요행을 바라면 실력이 늘지 않는다

스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수

1. 각 스테이지에 멈춰있는 플레이어의 수를 알아야하고
2. 해당 스테이지를 패스한 플레이어의 수를 합산하여 분모를 구해야한다
3. 나눠준다음 내림차순으로 정렬하여 스테이지 번호를 리턴해야한다

유추할 수 있는 것은
맵의 형태여야 3번 구현이 가능하다는 것이다
[{스테이지번호:실패율}, {스테이지번호:실패율}...]

입력값 => 5, [2, 1, 2, 6, 2, 4, 3, 3]

스테이지 자료를 만들면 풀린다

1. 스테이지에 멈춰있는 플레이어의 수
2. 스테이지를 겪고 있거나 겪은 플레이어의 수

배열을 돌면서 값마다 +1을 해준다

{
	1번스테이지:{
		멈춰있는수:	n,
		경험한수:	n,
	},
	2번스테이지:{
		멈춰있는수:	n,
		경험한수:	n,
	}
	...
}

0번 인덱스의 값은 2잖아
stageData[0].멈춰있는수 += 1;
stageData[0].경험한수 += 1;

근데 안에서 for문을 돌아야돼서
좀 더 깔끔하게 하려면 어떻게?

누적합으로 하면 어떨까
입력된 배열을 내림차순 정렬
[6, 4, 3, 3, 2, 2, 1]
6이면 1~5에 모두 +1을 해줘야됨
와 이거 for문 밖에 답 없나? 이중인데...
아 아니지
봐봐
6일 때 1을 쥐고 있어
4에서 1을 더하고 1을 더 기록해
3에서 2를 더하고 1을 더 기록해
이런 식으로 가면되지 않을까?
음...

아니다 봐봐
[1, 2, 2, 3, 3, 4, 6]
1일 때 (1)에 1 더하고
2일 때 (1)과 (2)에 1 더하고
3일 때 (1)과 (2)와 (3)에 1 더하고
아 어차피 돌려야되네;;

for문으로 처리해봅시다.

마지막 소트는
[...Array(N).keys()].map(a=>a+1).sort((a,b)=>
	스테이지자료[b].멈춰있는수/스테이지자료[b].경험한수
	- 스테이지자료[a].멈춰있는수/스테이지자료[a].경험한수
*/

// ㅎ... 가장 중요한건 단순하게 생각하는 것이다...
// 완전히 막혔다는 생각이 들 때 발상의 전환을 해야하는 듯...
// function solution(N, stages) {
//     let result = [];
//     for(let i=1; i<=N; i++){
//         let reach = stages.filter((x) => x >= i).length;
//         let curr = stages.filter((x) => x === i).length;
//         result.push([i, curr/reach]);
//     }
//     result.sort((a,b) => b[1] - a[1]);
//     return result.map((x) => x[0]); // 이렇게 2차원 배열 풀어낼 수 있음
// }
